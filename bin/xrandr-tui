#!/usr/bin/env  bash
# File: 	xdisplay / xrandr-tui
# Description:	A little helper around xrandr
# Disclaimer:   This code comes without any warrenty of any kind, use at your own risk!
# GNU General Public License (GPL) 2016 by Simon Arjuna Erat (sea) (erat.simon Ã¦ gmail,com)
# ------------------------------------------------------
#
#	Script Settings
#	Since it is a wrapper, lets define that all error messages are english
#
	export LC_ALL=C
	#set -x
#
#	Variables : Defaults
#
	# Get defaults
	XDG_SOURCED=false
	HOME="$(eval echo ~${USER})"
	XCD="${XDG_CONFIG_DIR:-$HOME/.config}"
	XDG_DIRS="${XCD}/user-dirs.dirs"
	[ -f "$XDG_DIRS" ] && source "$XDG_DIRS" && XDG_SOURCED=true
	# Repeate the leading 2 lines, since the initial variable might have changed
	XCD="${XDG_CONFIG_DIR:-$HOME/.config}"
	XDG_DIRS="${XCD}/user-dirs.dirs"
	! $XDG_SOURCED && source "$XDG_DIRS"
	LIST_DEFAULT_RESOLUTIONS_BOX="640x480 800x600 1024x768 1280x1024"
	LIST_DEFAULT_RESOLUTIONS_HD="640x360 854x480 1280x720 1920x1080 2560x1440 3840x2160"
	LIST_DEFAULT_RESOLUTIONS_WIDE="720x400 720x576 1152x864 1280x768 1280x960 1368x768 1440x900 1400x1050 1600x900 1680x1050 1600x1200"
	DEFAULT_DISPLAY=""
	DEFAULT_RESOLUTION=""
	SHOW_HZ=false
	SKIP_CHECK=${SKIP_CHECK:-false}
#
#	Script info
#
	script_name="xrandr-tui"
	script_version=0.4
	script_author="Simon Arjuna Erat (sea)"
	script_homepage="https://github.com/sri-arjuna/xrandr-tui"
	script_authors=""	# Add your names here, seperated by a comma ','
#
#	Variables : Messages
#
	MSG_HEADER_LEFT="$script_name ($script_version)"
	MSG_HEADER_RIGHT="Brought to you by (sea)" # & ${script_authors:-noone else}"
	MSG_TITLE="Current setup"
	MSG_MENU_TITLE="Welcome to the main menu"
	MSG_MENU_INTRO="What is your new setup?"
	MSG_CONFIG_UNUSED_DISPLAYS="With these unused (but connected) displays:"
	MSG_ORDER_FIRST="What is your first display (bottom,left) slot:"
	MSG_ORDER_OTHER="What is the next display?"
	MSG_ORDER_SOURCE="What is the source display?"
	MSG_ORDER_TARGET="Add a target?"
	MSG_SWITCH_INVALID_COUNT='Invalid count of connected displays: !2 = $(list.screens.connected)'
	MSG_SCREEN_SRC="Use this output slot as source:"
	MSG_DETECTED_SCREEN_SRC="Detected old active display slot:"
	MSG_DETECTED_SCREEN_TRGT="Selected new output slot:"
	MSG_DETECTED_SCREEN_MODE="Use mode/resolution autoselect?"
	MSG_SWITCH_RES="Please select the resolution for:"
	MSG_SELECT_RES_DISPLAY="Please select the display to change the resolution:"
	MSG_SELECT_RES="Please select the new resolution for:"
	MSG_MIRROR_NOTARGET="You have not selected a target for the mirror."
	MSG_SCREEN_MIRROR_SRC="Detected old active display slot:"
	MSG_SOURCE_CORRECT="Is this selection correct?"
	MSG_SOURCE_CORRECT_NOT="The first item you select as target, will be taken as source."
	MSG_LINEAR_SET_PRIMARY="Set primary screen (left):"
	MSG_LINEAR_SET_LEFT="The previous display is left, next right one:"
	MSG_LINEAR_SET_NEWLINE="The previous display is last right, next new line starts with output slot:"
	MSG_SET_PRIMARY="Set as primary screen (bottom,left) slot:"
	MSG_SCREEN_UPDATE="Next screen update in:"
	MSG_DEFAULT_MAIN="Which is your default display when resetting?"
	#MSG_DEFAULT_MAIN_=""
	MSG_DEFAULT_RES="What resolution shall be set when resetting?"
	#MSG_DEFAULT_RES_=""
	MSG_DEFAULT_HZ="Use the refresh rate (hz) of the created modes for the name as well?"
	MSG_MODE_ADD_TITLE="Add a new mode to slot:"
	MSG_MODE_ADD_KIND="What kind of mode would you like to add?"
	MSG_MODE_ADD_DISPLAY="Which display shall be used?"
	MSG_MODE_ADD_EXISTS="The mode you wanted to add does already exist"
	MSG_MODE_ADD_NEW="Please enter your desired resolution like: 1280x720"
	MSG_MODE_ADD_ASK="Are you sure to use this:"
	MSG_MODE_RM_TITLE="Remove an old mode from slot:"
	MSG_MODE_RM_ASK="Are you sure to remove this?"
		
#
#	Variables
#
	# Apps
	declare XR=\xrandr AWK=\gawk GREP=\grep SED=\sed LS=\ls WHICH=\which
	# Vars
	declare CONF="$XCD/$script_name.conf" RAW_DATA="" ORDER="" LISTLENGTH=15
	# other stuff
	first=true		# Menu tweak
	first_order=true	# MSG toggle tweak when setting order
#
#	Functions
#
	# Data handling
	data.get()  { export RAW_DATA="$(${XR}|$GREP -v Screen)" ; }
	data.show() { echo "$RAW_DATA" ; }
	data.cvt.get() { DATA_CVT=$(cvt ${res/x/" "} ${DEFAULT_HZ:-60}) ;}
	data.cvt.show() { echo "$DATA_CVT" ;}
	# Info of *-marked displays
	screen.name() { tmp=$(data.show | $GREP -B${LISTLENGTH} "*" | $GREP ^[a-zA-Z] | $AWK '{print $1}' | tail -n1);list.screens | $GREP $tmp; }
	screen.size() { data.show | $AWK '/*/ {print $1}' ; }
	# Lists
	list.screens() { data.show | $GREP ^[a-zA-Z] | $AWK '/ connected/ {print $1}' ; }
	list.screens.unused() { data.show | $GREP ^[a-zA-Z] | $GREP  $(for f in $(screen.name);do echo " -ve $f ";done)|$AWK '/ connected/ {print $1}' ; }
	list.screens.connected() { data.show | $AWK '/ connected/ {print $1}' ;}
	list.modes() { data.show | $GREP "$1" -A${LISTLENGTH} | $GREP -v "$1" | while read data _ ;do echo "$data" | grep -q ^[a-zA-Z] && break || echo $data;done; }
	list.menu() { tmp=$($GREP "task.*()" "$($WHICH $0)"|$GREP -ve "list.menu" -ve "task.quit" -ve "#" -ve ^"#"|$AWK '{print $1}');echo "${tmp//task.}"|$SED s,\(\)*,,g; }
	# Task functions
	task.quit() { exit 0 ; }
	task.switch() { 
	# Expects two connected displays
	# Switches the the active to off, and actives the off one
		tui-title "${FUNCNAME/task\.}"
		cur=$(screen.name)
		
		MSG_SWITCH_DISP_CUR="The current display is:"
		MSG_SWITCH_DISP_CHG="Do you want to use this?"
		
		tui-print -E "$MSG_SWITCH_DISP_CUR $cur"
		! tui-yesno "$MSG_SWITCH_DISP_CHG" && \
		
		tui-print -S $? "$MSG_DETECTED_SCREEN_SRC $cur"
		
		job.switch "$cur"
	}
	task.resolution() { 
	# Change the resolution for the current active display
	# Select which display if more than one is active
		tui-title "${FUNCNAME/task\.}"
		[ $(screen.name|grep [a-zA-Z]|wc -w) -gt 1  ] && \
			tui-print -E "$MSG_SELECT_RES_DISPLAY" && \
			this=$(tui-select $(screen.name)) || \
			this=$(screen.name)
		tui-print -E "$MSG_SELECT_RES" "$this"
		res=$(tui-select $(list.modes $this))
		
		(set -x;$XR --output $this --mode $res)
		exit $?
	}
	task.mirror() { # SRC TRGT1 TRGT2 ..
	# Take the first argument as source screen
	# Mirror all following from that
		tui-title "${FUNCNAME/task\.}" 
		ar_passed=($(echo "${@}"))
		src=${ar_passed[0]}
		unset ar_passed[0]
		tui-print -S $? "${MSG_SCREEN_MIRROR_SRC} $src"
		! tui-yesno "$MSG_SOURCE_CORRECT" && tui-print -E "$MSG_SOURCE_CORRECT_NOT"
		
		job.reset.all
		sleep 0.5
		(set -x;$XR --output $src --auto)
		for passed in ${ar_passed[@]}
		do
			thismode=$(list.modes $passed|head -n1)
			(set -x;$XR --output $passed --same-as $src --mode $thismode)
			tui-status $? "$MSG_DETECTED_SCREEN_TRGT $passed"
		
		done
		exit $?
	}
	task.linear() {
	# Take the first argument as source screen
	# Mirror all following from that
		tui-title "${FUNCNAME/task\.}" 
		ar_passed=(${@})
		src=${ar_passed[0]}
		unset ar_passed[0]
		
		job.reset.all
		(set -x;$XR --output $src --primary)
		tui-print -S $? "$MSG_LINEAR_SET_PRIMARY $src"
		for passed in ${ar_passed[@]}
		do
			(set -x;$XR --output $passed --right-of $src --mode $(list.modes $passed|head -n1))
			tui-print -S $? "$MSG_LINEAR_SET_LEFT $passed"
		done
		exit $?
	}
	task.mode.add() {
	# Add a new mode to current output
	#
		tui-title "$MSG_MODE_ADD_TITLE $(screen.name)"
		local list="box hd wide"
		prefix=LIST_DEFAULT_RESOLUTIONS
		
		tui-print -E "$MSG_MODE_ADD_KIND"
		item=$(tui-select $list)
		tmp="${prefix}_${item^^}"
		list_items=$(eval echo "\${${tmp}}" )
		display=$(screen.name)
		
		tui-print -E 
		tui-print -E "$MSG_SELECT_RES $display"
		res=$(tui-select $list_items custom)
		while [ "$res" = custom ]
		do	tui-print -E "$MSG_MODE_ADD_NEW"
			res=$(tui-read)
			tui-yesno "$MSG_MODE_ADD_ASK $res" || res=custom
		done
		data.cvt.get
		
		mode_lbl="$(data.cvt.show|$AWK '/Modeline/ {print $2}'|$SED s,\",,g)"
		mode_numbers="$(data.cvt.show|$AWK '/Modeline/ {print $3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13}')"
		
		list.modes $(screen.name) | $GREP -q "${mode_lbl/_*}" && \
			tui-print -S 1 "$MSG_MODE_ADD_EXISTS" && \
			exit 1
		$SHOW_HZ || mode_lbl="${mode_lbl/_*}"
		$XR --newmode $mode_lbl $mode_numbers
		$XR --addmode $display $mode_lbl
		$XR --output $display --mode $mode_lbl
	}
	task.mode.rm() {
	# Remove a mode from current output
	#
		display="$(screen.name)"
		
		tui-title "$MSG_MODE_RM_TITLE $display"
		res_rm=$(tui-select $(list.modes $display))
		
		if tui-yesno "${MSG_MODE_RM_ASK} $res_rm ($display)"
		then	$(set -x;$XR --delmode $display $res_rm)
			$(set -x;$XR --rmmode "$res_rm")
			
		fi
		return $?
	}
	#task.multiline() { tui-title "TODO ${FUNCNAME/task\.}" ; tui-list -1 $@ ; }
	task.reset() { job.reset.all ; $XR --output $DEFAULT_DISPLAY --mode $DEFAULT_RESOLUTION --primary ; }
	job.reset.all() { for d in $(list.screens.connected);do $XR --output $d --off;done;}
	task.config() { tui-conf-editor -H "$script_name ($script_version)" --write-no-exist --option DEFAULT_DISPLAY --values "$($0 --list-connected)" --default "$(screen.name)" --option DEFAULT_RESOLUTION --values "$(list.modes $(tui-conf-get $CONF DEFAULT_DISPLAY))" --default "$(screen.size)" --option DEFAULT_HZ --values "30 60 75 100" --default 60 --option SHOW_HZ --values "true false" --default "false" "$CONF" ;}
	job.firsttime() { tui-bol-dir "$XCD";touch "$CONF";task.config;}
	job.switch() { # CUR_SCRN
	# Expects two connected displays
	# Switches the the active to off, and activateses the off one
		tui-print -T "${FUNCNAME/task\.}"
		cur="$1" ; [ -n "$cur" ] 
		tui-status $? "$MSG_DETECTED_SCREEN_SRC" "$cur" || exit 1
		
		new=$(list.screens);RET=$?
		new="${new/$cur}"
		tui-print -S $RET "$MSG_DETECTED_SCREEN_TRGT" "$new"
		
		tui-yesno "$MSG_DETECTED_SCREEN_MODE" && \
			MODE=$(list.modes $new | head -n1) || \
			{ tui-print -T "$MSG_SWITCH_RES" "$new" ;MODE=$(tui-select $(list.modes $new));}
		
		(set -x;$XR --output $cur --off)
		(set -x;$XR --output $new --mode $MODE)
		exit $RET
	}
	# Show repeated stuff
	show.config.current() { C=0;while [ -n "${AR_SCRN[$C]}" ] ;do tui-print -E "${AR_SCRN[$C]}" "${AR_RES[$C]}";((C++));done;tui-print -E "$MSG_CONFIG_UNUSED_DISPLAYS" "$(list.screens.unused)";}
	show.version() { printf '%s\n' "$script_name, Version $script_version" "Copyright (C) 2015 by $script_author" "License GNU General Public License (GPL) or later <http://www.gnu.org/licenses/gpl.html>" "" "This is free software; you are free to change and redistribute it." "There is NO WARRANTY, to the extent permitted by law.";exit 0;}
	show.help() {
	# Show help screen
	# Can be transformed to a manpage using txt2man
		cat <<-EO_SCREEN
		NAME
		 		$script_name
		
		SYNOPSIS
		 		$script_name [--help|--version] [-C|--config] [--reset] [--list-connected] [--list-unused]
		
		DESCRIPTION
		 		This is wrapper/wizard around the (xorg-)xrandr application.
		
		OPTIONS
		 		-h|--help		Show this screen and exit
		 		--version		Show the version and exit
		 		-C|--config		Edit the configuration
		 		
		 		--list-connected	List connected slots and exit
		 		--list-unused		List free slots and exit
		 		--list-used		List used slots and exit
		 		
		 		--reset			Reset xrandr settings according to configuration
		 		--switch		Switches the output of the current active one with the unused
		 		--mirror		Mirrors all connected output from DEFAULT_DISPLAY ($DEFAULT_DISPLAY)
		 		
		SEE ALSO
		 		cvt(1), tui(1), xrandr(1)
		
		AUTHORS
		 		$script_author, $script_authors
		 
		EO_SCREEN
		exit 0
	}
#
#	Action & preparations
#
	data.get
	declare -a AR_SCRN=($(screen.name)) 
	declare -a AR_RES=($(screen.size))
	$SKIP_CHECK ||  { [ -f "$CONF" ] || job.firsttime ; }
	source "$CONF"
#
#	Action : Get options
#
	GETOPT=$(getopt \
		--options	"hCL" \
		--longoptions	"help,version,config,mirror,list-unused,list-used,list-connected,reset,switch" \
		--name 		"${0##*/}" -- "${@}" \
	)
	eval set -- "${GETOPT}";
	while true
	do 	case "$1" in
		-h|--help)	show.help	;;
		--version)	show.version	;;
		--)		shift ; break	;;
		-C|--config)	task.config
				exit $?
				;;
		# -----------------------------------------------
		--list-connected)
				SKIP_CHECK=true list.screens.connected
				exit 0
				;;
		--list-unused)
				SKIP_CHECK=true list.screens.unused
				exit 0
				;;
		--list-used)
				screen.name
				exit 0
				;;
		--reset)	task.reset
				exit $?
				;;
		--switch)	# Switch silently, to be used for WMs hotkey-binding as example
				job.switch "$(screen.name)"<<-EO_SCRIPT
				y
				EO_SCRIPT
				exit $?
				;;
		--mirror)	# Switch silently, to be used for WMs hotkey-binding as example
				task.mirror "$DEFAULT_DISPLAY $(list.screens.connected|$SED s,$DEFAULT_DISPLAY,,g)"<<-EO_SCRIPT
				y
				EO_SCRIPT
				exit $?
				;;
		esac
	done
#
#	Display
#
	while :;do ! $first && tui-wait 3 "$MSG_SCREEN_UPDATE" || first=false ; clear
		tui-print -H "$MSG_HEADER_LEFT" "$MSG_HEADER_RIGHT"
		tui-print -T "$MSG_TITLE"
		show.config.current
		
		tui-print -T "$MSG_MENU_TITLE"
		tui-print -E "$MSG_MENU_INTRO"
		
		# Get action
		action=$(tui-select quit $(list.menu))
		# Quit or define order of displays
		if [ "$action" = "quit" ]
		then	task.$action
		elif [ -z "$ORDER" ]
		then	case "$action" in
			linear|multiline)
				item=""
				while 	[ ! done = "$item" ]
				do
					ORDER+=" $item"
					$first_order && \
						tui-print -E "$MSG_ORDER_FIRST" && \
						first=false || \
						tui-print -E "$MSG_ORDER_OTHER"
					item=$(tui-select done $(list.screens))
				done
				;;
			mirror)
				tui-print -E "$MSG_ORDER_SOURCE"
				SOURCE=$(tui-select $(list.screens.connected))
				
				this=""
				while 	tui-print -E "$MSG_ORDER_TARGET"
					tui-print -E "Src: $SOURCE // Targets: $TARGET"
					this=$(tui-select done $(list.screens.connected|$SED s,"$SOURCE",,g))
					[ ! done = $this ]
				do
					TARGET+=" $this";this=""
				done
				[ -z "$TARGET" ] && tui-print -S 1 "$MSG_MIRROR_NOTARGET" && exit 1
				ORDER="$SOURCE $TARGET"
				;;
			switch)	[ 2 -ne $(list.screens|wc -w) ] && \
					tui-print -S 1 "$MSG_SWITCH_INVALID_COUNT" && \
					exit 1
				;;
			esac
		fi
		# Execute the selected action
		task.$action $ORDER
		ORDER=""
		SOURCE=""
		TARGET=""
	done
#
#	Clean up
#
	set +x
