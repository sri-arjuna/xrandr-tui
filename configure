#!/usr/bin/env bash
#			Yet Another Simple Script Installer
# ------------------------------------------------------------------------
# Copyright (c) 2015 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#
#	Created:	2015.02.27
#	Transformed:	2015.12.07
#	Changed:	2015.12.20
	script_name=configure
	script_version=1.8.6
#
#	Description:
#		This script automaticly generates,
#		according to passed options, the following files, 
#		named to go along with GNU Automake terminology.
#		* make
#		* make-install
#		* make-install-all
#		* make-uninstall
#		* make-check
#		* make-clean
#		* make-distclean
#		* make-doc-{info,html,dvi,pdf,ps}
#		* make-check
#		* make-installdirs
#		* make-mostlyclean
#		* make-maintainer-clean
#		* Makefile
#
#	YASSI aims to be an easy to use 'configure' handler for projects that do not need binary compiling.
#	It also aims for portability as it can write a Makefile for the create scripts.
#
#	As home- or end-user you will probably only want to read:   ./configure --help
#	As a developer or packager, you will prefer the details on: ./configure --manpage
#
#	To report bugs or suggestions about YASSI (configure), 
#	* please raise an issue on:			https://github.com/sri-arjuna/yassi/issues
#	* or send me an email, subject YASSI:		erat.simon@gmail.com
#	
# ------------------------------------------------------------------------
#
#	Clear data of previous / other runs
#
	unset CHROOT DESTDIR
	unset ${!APP_*} ${!AUTHOR_*} ${!MAINTAINER_*} ${!MAILLIST_*} BUGTRACKER
	unset DOWNLOAD_IF_MISSING DOWNLOAD GIT SVN
	unset REQS DEPS DOCS MAKE PRIOR POST UNINSTALL CLEAN DISTCLEAN IGNORE CHECK INSTALLDIRS MOSTLYCLEAN MAINTAINER_CLEAN
	unset doMakefile doGNU doTUI doRef
	unset ${!DIR_*}
#
#	Set command-tools help output to english and bypass alias'
#
	export LC_ALL=C
	declare AWK=\gawk GREP=\grep LS=\ls SED=\sed WHICH=\which
#
#	Prepare cleared arrays and variables
#
	# Arrays
	declare -A FHS DOCS REQS 
	declare -a MAKE PRIOR POST UNINSTALL CLEAN IGNORE CHECK INSTALLDIRS
	# Variables
	declare APP_NAME="APPNAME" APP_VER APP_LIC \
			APP_TITLE APP_PRJ APP_HOMEPAGE \
			APP_DIR="${PREFIX:-/usr/local}"
	declare AUTHOR_NAME AUTHOR_EMAIL AUTHOR_HOMEPAGE
	declare MAINTAINER_NAME MAINTAINER_EMAIL MAINTAINER_HOMEPAGE
	declare BUGTRACKER DOWNLOAD_IF_MISSING DOWNLOAD GIT SVN DEPS
	declare CFG="${CFG:-./configure.yassi}" REF MANPAGE="/tmp/yassi.1"
	# Bools
	declare doMakefile=false doGNU=false doTUI=false doRef=false
	declare VERBOSE=false DEBUG=false	## V=1 // V=2
	# Basic 'compatiblity' with the 'prepass V=[1|2] toggle' (covers --verbose (V=1) and --debug (V=2))
	[ -n "$V" ] && VERBOSE=true && [ $V -eq 2 ] && DEBUG=true 
#
#	Message Strings
#
	[ -f "$CFG" ] && source "$CFG"
	# List supported 'error message' languages here:
	YASSI_LANGS=" "
	# Parse for any found language, or fallback to 'en_GB'
	for lng in $YASSI_LANGS en_GB
	do 	# If lng is not default, check if LANG and lng are the same lang, even if not country.
		[ ! $lng = en_GB ] && L="${LANG##\.*}" && { [ "${L/_*}" = "${lng/_*}" ] || continue ; }
		case "${lng:-en_GB}" in
		en_*)	MSG_NO_CODE="Fatal error, could not retrieve project (${APP_NAME^^}) code!"
			MSG_NO_CONFIG="Configuration file ($CFG) not found!"
			MSG_NO_NAME="Missing APP_NAME..."
			MSG_NO_INTERNET="No working internet connection found."
			MSG_NO_REQS="Did not find the following required commands:"
			MSG_NO_DL_APP="Could not find: curl/wget!"
			MSG_CANNOT_EXE_DIR='Cannot execute a directory: $1!'
			MSG_MISSING_CMDS="Please provide these commands before configuring $APP_NAME!"
			MSG_NO_TEXI="The command 'texi2any' was not found, which is required to create this manual"
			MSG_TARBALL_GOOD="Successfully created tarball"
			MSG_TARBALL_BAD="There was an error building the tarball"
			MSG_REQS_ONE="Please install at least one of these commands:"
			MSG_REQS_OPTS="You might like to install one of these too:"
			MSG_RERUN_CFG="Please rerun ./configure with your settings."
			#MSG_=""
			break
			;;
		esac
	done
#
#	Default path list
#
	mandirs="mandir $(echo man{1..9}dir)"
	list_index="prefix bindir sbindir  sysconfdir datarootdir appdir icondir datadir docdir htmldir infodir $mandirs dvidir pdfdir psdir compldir sharedstatedir localstatedir rootdir bootdir efidir grubdir"
	list_variables="";for i in $list_index;do list_variables+=" ${i^^}";done
#
#	Version & Help
#
	show_version() {
	# Prints the version of the script
	# and exits
		cat <<-EO_SCREEN
		./configure, Version $script_version
		Copyright (C) 2015 by Simon Arjuna Erat, erat.simon@gmail.com
		License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
		
		This is free software; you are free to change and redistribute it.
		There is NO WARRANTY, to the extent permitted by law.

		Report bugs of ./configure to: <https://github.com/sri-arjuna/yassi/issues>
		Or send an email to: <erat.simon@gmail.com>
		EO_SCREEN
		exit 0
	}
	show_paragraph() { # NODE "CONTENT"
	# Prints a helptext block
	# that is usable as manpage 
		printf "\n%s\n" "${1^^}" ; shift
		for a in "${@}";do printf "\t%s\n" "$a";done
	}
	show_help() {
	# Prints the helpscreen
	# and exits
		[ -n "$APP_LIC" ] && \
			scr_lic="$(show_paragraph license "${APP_LIC}" " ")" || \
			src_lic=""
		app_ver=""
		[ -n "$APP_VER" ] && \
			 app_ver=" (${APP_VER})" || \
			 app_ver=""
		
		cat <<-EO_SCREEN
		SYNOPSIS
		  	./$script_name [options]
		
		DESCRIPTION
		 	Routine to configure the installation of "${APP_TITLE:-${APP_NAME:-APPNAME}}$app_ver"
		$scr_lic
		BASIC
		 	-h|--help		Shows this screen and exits
		 	--version		Shows the version of YASSI (./configure) and exits
		 	--verbose		Prints all the action of the make* commands on the screen (V=1 ./configure [opts])
		 	--debug			Like --verbose but also internal action how those files are created (V=2 ./configure [opts])
		
		 	--prefix DIR		Sets the prefix to DIR		(default: PREFIX=${APP_DIR})
			
		DIRECTORIES	
		 	--bindir DIR		user executeables 		(\$PREFIX/bin)
		 	--sysconfdir DIR	read-only single-machine data 	(\$PREFIX/etc)
		 	--datadir DIR		read-only architecture-independent data (\$DATAROOTDIR/${APP_NAME:-APPNAME})
		 	--compldir DIR		Bash completion				(\$DATAROOTDIR/bash-completion/completions)
		 	
		 	--datarootdir DIR	read-only arch.-independent data root 	(\$PREFIX/share)
		 	--localedir DIR		locale-dependent data			(\$DATAROOTDIR/locale)
		 	--localstatedir	DIR	modifiable single-machine data		(\$PREFIX/var)
		 	--sbindir DIR		admin executeables			(\$PREFIX/sbin)
		 	--sharedstatedir DIR	modifiable architecture-independent	(\$PREFIX/com)
			
		DOCUMENTION
		 	--docdir DIR		Project documentation root	(\$DATAROOTDIR/doc/${APP_NAME:-APPNAME})
		 	--infodir DIR		Info documentation		(\$DATAROOTDIR/info)
		 	
		 	--mandir DIR		Basedir for manpages		(\$DATAROOTDIR/man)
		 	--man[1-9]dir DIR	Specific manpage dirs		(\$MANDIR/man/man[1-9])
		 	
		 	--htmldir DIR		Project documentation root	(\$DOCDIR)
		 	--dvidir DIR		Project documentation root	(\$DOCDIR)
		 	--pdfdir DIR		Project documentation root	(\$DOCDIR)
		 	--psdir DIR		Project documentation root	(\$DOCDIR)
		 	
		GUI
		 	--appdir DIR		*.desktop files			(\$DATAROOTDIR/applications)
		 	--icondir DIR		Icons for the desktop files	(\$DATAROOTDIR/icons)
		 
		REDISTRIBUTION
		 	--chroot DIR		Sets the CHROOT to DIR		(for 'builddirs' or before chrooting into a partition)
		 	--tarball		Equivalent of: "./configure [opts] && (./make-tarball || make dist)"
		 	--makefile		Writes a dynamic Makefile according to created scripts
		
		DEVELOPERS
		 	--sample		Prints a mini example for a '$CFG'
		 	--sample-full		Prints a template with all options of a '$CFG'
		 	--sample-full-clean	Prints the same template without comments.
		 	--manpage		Prints an advanced help screen for developers and packagers
		 
		NOTES
		  Common Prefix Locations
		  	Common places that are used as --prefix=DIR:
		  	* / or /usr
		 	* /usr/local or /opt
		 	* \$HOME or \$HOME/usr
		 	* \$HOME/local or \$HOME/.local
		
		EO_SCREEN
		
		# Print messages according to passed configuration file
		[ -n "$AUTHOR_NAME" ] && echo "The project \"${APP_NAME^^}\" was written by \"$AUTHOR_NAME\" <$AUTHOR_EMAIL> ($AUTHOR_HOMEPAGE)"
		[ -n "$APP_HOMEPAGE" ] && echo "To learn more about \"${APP_TITLE:-$APP_NAME}\" visit: <$APP_HOMEPAGE>"
		[ -n "$MAINTAINER_NAME" ] && echo "This package of \"${APP_TITLE:-$APP_NAME}\" is maintained by \"$MAINTAINER_NAME\" <$MAINTAINER_EMAIL> ($MAINTAINER_HOMEPAGE)"
		[ -n "$MAILLIST_NEWS" ] && echo "To stay informed about \"${APP_NAME^^}\", subscribe to: <$MAILLIST_NEWS>"
		[ -n "$MAILLIST_BUGS" ] && echo "To report bugs about \"${APP_NAME^^}\", please send a descriptive email to <$MAILLIST_BUGS>"
		[ -n "$BUGTRACKER" ] && echo "If you experience any bugs or errors using \"${APP_NAME^^}\", please raise an issue on <$BUGTRACKER>"
		exit 0
	}
	show_manpage() { #
	# Prints the developer manpage
	# -> basic text prepared for txt2man where available
		cat <<-EO_SCREEN
			DESCRIPTION
			 	This manpage shall explain how to write/modify a YASSI configuration file.
				
				This part of the manual is still in progress and also describes functionality that is still in developement or not yet stable.
				
				Further it handles the topcis like the full sample from top to down.
				
			SYNTAX
			 	VARNAME=file		Assign this file to be installed to VARNAME
			 	VARNAME=dir1		Assign only content of this dir to be install to VARNAME
			 	VARNAME=./dir2		Assign this dir and all its content to be installed to VARNAME
			 	VARNAME=dir3/[RI]*.md	Assign all files starting with capital 'R' and 'I' and ending with '.md' to be installed to VARNAME 
			 	VARNAME="file dir ./dir dir2/[RI*.md]"	All above syntax can be combined within a list
				
				TASK_LIST[0]="entry"	Depending on the kind of the TASK_LIST[@]:
							* Dirs/Files either get executed or removed
							* Non found entries either gets removed or printed 'as is'
			 	
		 	Exceptions are: REQS[<TYPE>] and DEPS, please see details below.
				
			PROJECT INFO
				This section explains most of the variables visible to the enduser by looking at --help.
				  
				APP_NAME	The unix shortname of the project. 
						This name is also used for installation path
				APP_VER		Set the project version, this is also used in/on:
						  * the --help screen 
						  * the tarball will contain version number
						  * Can be used to keep $DOWNLOAD up-to-date (see: Advanced: Mini Installer)
				APP_LIC		Set the license of your project
				APP_TITLE	Someimtes a title is more that just one word
				APP_PRJ		Is this project part of another project? What is its name?
				APP_HOMEPAGE	Where to get the latest information about the project?
				APP_DIR		Set another default path for ./configure (default /usr/local)
				
			AUTHOR AND MAINTAINER INFO
				{AUTHOR,MAINTAINER}_NAME	Name of Author / Maintainer
				{AUTHOR,MAINTAINER}_EMAIL	Email of Author / Maintainer
				{AUTHOR,MAINTAINER}_HOMEPAGE	Homepage of Author / Maintainer
				
			PROJECT CONTACT
				MAILLIST_NEWS	Newsletter for \$APP_NAME
				MAILLIST_BUGS	Email to send bugs to
				BUGTRACKER	Website to report bugs or raise issues
			
			BOOLEANS
			  Syntax: doBOOLNAME=true
			 	
			 	There are a few optional bool'ish helpers, by default they are set to false:
			 	
			 	doMakefile	It is quite obvious what doMakefile does if it is set to true.
			 	doGNU		If not provided by the author of the project, it adds some targets to the Makefile
			 	doRef		installs the reference file of the used paths to /etc/appname.conf, 
			 			if enabled, the file is also uninstalled automaticly.
			 			If you need to apply the systems absolute paths into your scripts, use the \$REF for your TASK's in your $CFG.
			 	doVer		Some projects require to have the version in their path name 'doVer' does that.
			 	doTUI		As I wrote YASSI for myself, this doTUI toogle will install the Text User Interface,
			 			framework for scripts before the the actual install.
			
			REQS
			  Syntax: REQS[<TYPE>]="list of required commands"
			  
			  	REQS[app]	Your project requires these commands and cannot run without them
			 	REQS[make]	This command is required to prepare the/your project files
			 	REQS[opt]	This command can improve usablity for your project but is not essential
			 	
			 	Why this destinction?
			 	
			 	In regards of the 'app' it is quite obvious, configure will exit with failure (1) if any of these commands is missing.
			 	
			 	The same behaviour is for 'make', as that should contain a list of commands that are required to 'make' preparations for your projct before it gets installed.
			 	
			 	'opt' on the other hand will only print a messsage to the user and let him know that it might be cool to install the missing commands of this list.
			 	
			 	
			 
			DIRECTORIES
				This is where the actual magic happens...
				
				Basicly all files and directories assigned to any of the *DIR variables according to above provided SYNTAX,
				will get installed to the directory represented by the VARNAME*DIR (eg: BINDIR).
				
				Please see: ./configure --help for a list of supported dirnames, note that the variables must be in CAPITAL letters.
			
			DOCS
			 	Is a nice handler to create texi documents.
			 	
			 	Each of the following assignments will create a specific: make-doc-<TYPE> file.
			 	
			 	Supported TYPE's are: info, html, pdf, dvi and ps.
			 	
			 	DOCS[\$TYPE]=docs/texi/\$APP_NAME.texi	The created script will create the info document.
			 	
			 	DOCS[info]="docs/texi\$APP_NAME.texi docs/texi/other-node.texi" Also multiple entries are supported.
			 	
			 	There is no need to handly the 'texi2any' requirement, using DOCS[TYPE] will inform the user if it is missing.
			 	Also, it will not allow the user to delete (./make-clean) these docs if 'texi2any' is not available.
			 	
			 	While this only takes care of creating these docs, you still need to place them for the installation:
			 	
			 		INFODIR=docs/tex/*.info
			 		HTMLDIR=docs/tex/*.html
			 	
			 	Upon ./configure, ./make-doc-<TYPE> will be created.
			 	
			 	Upon ./make-doc-<TYPE>, it will check if 'texi2any' is avilable or not.
			 	
			 	Upon ./make-install-all, all available ./make-doc-* are executed before the actual ./make-install script.
			 
			 
			ADVANCED
			REDISTRIBUTION
				--chroot=DIR	Install \$APP_NAME to DIR/\${PREFIX}
						This setting can be overwritten by passing DESTIDR=DIR to make.
				--tarball	Packages a tarball of the project dir from parent dir
				--makefile	If a Makefile should be required or desired
			
			ADVANCED
			MINI INSTALLER
			 	These tools are nice if you want to share your application with a very low storage requirement.
			 	
			 	DOWNLOAD_IF_MISSING	Only if this DIR or FILE is not found, it triggers the other download preferences.
			 				This DIR or FILE should NOT be created by ./make but exist and be required anyway.
			 	GIT			Set the GIT URL to clone from (prefered)
			 	SVN			Set the SVN URL to checkout from (2nd)
			 	DOWNLOAD		Download this tarball
			 	DOWNLOAD_DIR		Only required if the extracted tarball has another dirname than:
			 				* \$APP_NAME
			 				* \$APP_NAME-master
			 				* \$APP_NAME-\$APP_VER
			 	
			 	For GIT and SVN downloads, a directory named "\$APP_NAME.src" will be created.
			 	The TARBALL will be downloaded and exracted and the path checked.
			 	
			 	Afterwards YASSI changes its PWD to the new directory and continue installation.
			
			ADVANCED
			TARBALL
			
			  A tarball is usally not required, unless you create them manual for upstream, now this can be partialy automated!
			  
			 	TARBALL 	Set alternate output file (default: ../\$APP_NAME[-\APP_VER].tar.gz)
			 	TARBALL_DIR	Set custom output path, but let YASSI decide the filename
			 	IGNORE  	Ignore these entries when creating the tarball
			
			 	A tarball can be created by either:
			 	
			 		./configure --tarball
			 		./configure --makefile ; make dist
			 
			ADVANCED
			VARIABLES PRESETS
			 	These variables may be placed in front of ./configure and will influence the behavior of YASSI.
			 	
			 	CFG=file	This is the same as "./configure --conf file"
			 	DESTDIR 	This is the same as ./configure --chroot=dir,
			 			but it can also overwrite the previous set CHROOT by
			 			passing "DESTDIR=dir make install"
			 	TARBALL 	By default the created tarball will reside in the top dir, use this to change the location
			
			
			ADVANCED
			CUSTOM DIRECTORIES	
			 	You may define and use custom paths, be aware that you probably have to handle them your own.
			 	
			 	To define a new TARGET DIR, use:
			 	
			 		DIR_DEMO='$DATADIR/demo'
			 		
			 	Then to assing the installer to install files there:
			 	
			 		DEMO_DIR=demo/my*files
			 	
			 	NOTE: This is a hardcore example of what could have been:
			 	
			 		DATADIR=./demo
			
			ADVANCED
			TASKS
			 	If you need to generate some files, for example a file containing the absolute paths of the system it is installed to,
			 	you can do that by adding one or multiple MAKE array entries:
			 	
			 		MAKE[0]="cat scripts/template.sh > bin/myapp"
			 	
			 	You could also let ./make execute other scripts:
			 	
			 		MAKE[1]=scripts/prepare.sh
			 		
			 	Or print a message to the user:
			 	
			 		MAKE[2]='echo "Hello $USER"'
			 	
			 	Likewise for PRIOR[0] and POST[0], but those will be executed before and after the actual installation of the TARGETs.
			 	
			 	The obvious exceptions are: UNINSTALL[0], CLEAN[0], DISTCLEAN[0], and IGNORE[0].
			 	IGNORE is used for --tarball (make dist), the others obvious for their make-<COMMAND>s.
			 
			ADVANCED
			DEPS
			
			  Syntax: DEPS="deps/first.yassi deps/second.yassi"
			 
			 	BETA IN PLAN
			 	This will install each of the passed dependencies before the actual install.
			 	
			 	YASSI will change its PWD to each of the DEP files and the call its default routines to install this passed configuration.
			
			 	
			AUTHOR
			 	YASSI was started in early Feb 2015 by Simon Arjuna Erat from Switzerland.
			 	
			 	
		EO_SCREEN
	}
	show_sample() { #
	# Prints a minimal example config
	#
		cat <<-EO_SCREEN
		#!/usr/bin/env bash
		# This configure.yassi was generated on $(date +'%F') using YASSI ($script_version)
		#
		#	Project Info
		#
		 	APP_NAME=myapp			# Install name of the application, \$PREFIX/share/\$APP_NAME
		 #	APP_VER=0.5b			# Optional, Show Versionnumber
		 #	APP_LIC=GPLv3+			# Optional, Show License
		 #	APP_HOMEPAGE="mywebsite.web" 	# Optional, homepage of project
		 #	AUTHOR_HOMEPAGE="mywebsite.web" # Optional, your personal homepage
		 #	AUTHOR_NAME="My Name"		# Optional, Name of author
		 #	AUTHOR_EMAIL="some@mail.web"	# Optional, Email of author
		 
		#
		#	Default target dirs
		#
		 	BINDIR=bin			# All files in folder 'bin' will be installed to \$PREFIX/bin
		 	SYSCONFDIR=myapp.conf		# Installs myapp.conf to \$PREFIX/etc
		 	DATADIR="./lists ./templates"	# Copies both directories to \$PREFIX/share/myapp/{lists,templates}
		 
		EO_SCREEN
		exit 0
	}	
	show_sample_full() { #
	# Prints a full empty template with comments
	#
		cat <<-EO_SCREEN
		#!/usr/bin/env bash
		# This configure.yassi was generated on $(date +'%F') using YASSI ($script_version)
		# Copyright (c) $(date +'%F') by ${USER_NAME:-$USER}  <${USER_EMAIL:-$USER@$HOSTNAME}>
		# All rights reserved.
		#
		# This program is free software: you can redistribute it and/or modify it
		# under the terms of the GNU General Public License as published
		# by the Free Software Foundation, either version 3 of the License, or
		# (at your option) any later version.
		#
		# This program is distributed in the hope that it will be useful,
		# but WITHOUT ANY WARRANTY; without even the implied warranty of
		# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		# GNU General Public License for more details.
		#
		# You should have received a copy of the GNU General Public License
		# along with this program.  If not, see <http://www.gnu.org/licenses/>
		#
		#
		#	Project Info
		#	-- This info is shown on the default ./configure --help screen.
		#
		 	APP_NAME=		# Install name of the application, \$PREFIX/share/\$APP_NAME
		 #	APP_VER=		# Optional, Show Versionnumber
		 #	APP_LIC=GPLv3+		# Optional, Show License
		 #	APP_TITLE=""		# Optional, Show long title
		 #	APP_PRJ=""		# Optional, Name the parent project
		 #	APP_HOMEPAGE=""		# Optional, Website of the project
		 #	APP_DIR=/usr/local	# Optional, Used as default PREFIX if none is passed
		#
		#	Author & Package Maintainer Info
		#	-- This info is shown on the default ./configure --help screen.
		#
		 #	AUTHOR_NAME=""		# Optional, Name of author
		 #	AUTHOR_EMAIL=""		# Optional, Email of author
		 #	AUTHOR_HOMEPAGE=""	# Optional, Website of author
		 #	MAINTAINER_NAME=""	# Optional, Name of author
		 #	MAINTAINER_EMAIL=""	# Optional, Email of author
		 #	MAINTAINER_HOMEPAGE=""	# Optional, Website of author
		 #	MAILLIST_NEWS=""	# Optional, address of maillist to get news
		 #	MAILLIST_BUGS=""	# Optional, address of maillist to send bugs to...
		 #	BUGTRACKER=""		# Optional, adress to visit if no maillist is available but a bugtracker system
		#
		#	YASSI Booleans
		#
		 #	doMakefile=false	# Optional, Write a Makefile according to created scripts
		 #	doGNU=false		# Optional, like doMakefile, but write additional TARGETs to the Makefile, 
		 #				# if the according scripts are not created by the $CFG
		 #	doTUI=false		# Optional, Install TUI (BETA TODO)
		 #	doRef=false		# Optional, Install \${APP_NAME}_dirs.conf to \$SYSCONFDIR/\$APP_NAME.conf
		 #	doVer=false		# Optional, Use \$APP_VER for the DATADIR (\$DATAROOTDIR/\$APP_NAME-\$APP_VER)
		#
		#	Requirements
		#
		 #
		#	Requirements
		#
		 #	REQS[app]="bash which"	# Detailed checks, MODE ('app') may be: app, make or opt.
		 #	REQS_ONE[0]="curl wget"	# For each entry at least one of the commands must be found
		 #	DEPS=""			# Install these *.yassi configure files before anything else, see more in ./configure --manpage
		#
		#	Create documentions
		#
		 #	DOCS[info]=		# Optional, Add *.texi files to the list and texi2any will convert them with ./make-doc-info
		 #	DOCS[html]=		# See more in ./configure --manpage
		 #	DOCS[pdf]=		# But also for: dvi and ps
		#
		#	Default target dirs
		#
		 	# Basic
		 	BINDIR=bin			# This still install all files into \$PREFIX/bin
		 #	SBINDIR=			# Optional, see --help for its default path
		 	SYSCONFDIR="cfg/{a,b}.cfg" 	# This will install a.cfg and b.cfg to \$PREFIX/etc
		 #	DATAROOTDIR=			# Optional, see --help for its default path
		 	DATADIR="./dir1 dir2 file1"	# Copy ./dir1, content of 'dir2' and file1 to \$PREFIX/share/\$APP_NAME
		 #	COMPLDIR=
		 #	LOCALEDIR=
		 #	LOCALSTATEDIR=
		 #	SHAREDSTATEDIR=
		 
		 	# GUI			# --> See "./configure --help" for their default paths
		 #	APPDIR=			# Optional, Install *.desktop files
		 #	ICONDIR=		# These dirs have subfolders, which you must provide as well
		 
		 #	# Docs
		 	DOCDIR="[RCI]* docs"	# Installs all files with capital starting letters R, C or I, 
		 				# and all content of 'docs' to \$PREFIX/share/doc/\$APP_NAME
		 #	INFODIR=		# Either precompiled (recomeded!) or/and as DOCS[info]=file.texi generated.
		 #	HTMLDIR=		# Like INFODIR, as well for pdfdir, dvidir, psdir.
		 #	PDFDIR=
		 #	DVIDIR=
		 #	PSDIR=
		 	MANDIR=./man1		# The offical target directory, contains subfolders per section
		 #	MAN1DIR=mans/*.1	# These numbered variables grant direct access to their respective manpage dir.
		 #	MAN8DIR=
		#
		#	Advanced: Mini Installer
		#
		 #	DOWNLOAD_IF_MISSING="bin/script.sh"	# If this file or dir is missing, try the provided download options
		 #	GIT=""			# First choice to retrieve code from git to ./\$APP_NAME.src
		 #	SVN=""			# Some still use this, goes also to ./\$APP_NAME.src
		 #	DOWNLOAD=""		# Last resort to download a tarball, prefer curl over wget
		 #	DOWNLOAD_DIR=""		# What is the name of the folder of the extracted tarball. (\$APP_NAME-{master,\$APP_VER} are automaticly reckognized)
		 
		#
		#	Advanced: Tarball (--tarball ; make dist)
		#
		 #	TARBALL="\${HOME}/\${APP_NAME}.tar.gz" # Where to save the tarball? Default: ../\$APP_NAME.tar.gz -- ../\${APP_NAME}-\${APP_VER}.tar.gz
		 #	TARBALL_DIR="\$HOME"	# Let YASSI create the filename, but save it here
		 #	IGNORE[0]=".git"	# Besides Makefile + make*, which files should be ignored for tarball?
		 
		#
		#	Advanced Tweakings
		#
		 #	MAKE_CREATES=		# Optional, If this file is missing, make install wont start
		 #	MAKE[0]="python ./scripts/script.py"	# Optional, Tasks to be done by ./make
		 #	PRIOR[0]=""		# Optional, Tasks prior to installation (./make-install)
		 #	POST[0]=""		# Optional, Tasks post to installation (./make-install)
		 #	UNINSTALL[0]=""		# Optional, additional tasks to be done by ./make-uninstall, required to undo possible PRIOR or POST operations
		 #	CLEAN[0]="to-delete.file"		# Optional, Tasks to be done by ./make-clean
		 #	DISTCLEAN[0]=""		# Optional, Tasks to be done by ./make-distclean
		 #	Likewise for:		MAINTAINER_CLEAN MOSTLYCLEAN INSTALLDIRS
		#
		#	Custom Target Paths
		#
		 	# Example
		 # 	DIR_DEMO='$DATAROOTDIR/demos/$APP_NAME'
		 # 	DEMO_DIR=mydata/*
		 	
		EO_SCREEN
		exit 0
	}
	# Prints the full template but removes the comments
	show_sample_full_clean() { show_sample_full | sed s,"	#..*","",g;}
#	Functions
#	
	task_reference() { # INDEX
	# Prints the index reference used
	#
		ref_val="${FHS[${1,,}]}"
		echo "${1}=$ref_val"  | $SED s,"//","/",g
	}
	task_tui() { #
	# This will install TUI prior to, but with $APP_NAME
	#
		local GIT="git://git.sv.gnu.org/tui.git"
		local DOWNLOAD="http://git.savannah.gnu.org/cgit/tui.git/snapshot/tui-master.tar.gz"
		local GIT="http://github.com/sri-arjuna/tui.git"
		get_it(){
			ping -c1 8.8.8.8 2>/dev/null >&2 || \
				{ echo "$MSG_NO_INTERNET" ; exit 1 ; }
			if which git 2>/dev/zero 1>/dev/zero 
			then	if [ -d tui-master ]
				then	cd tui-master
					git pull
					RET=$?
				else	git clone "$GIT" tui-master
					RET=$?
					cd tui-master
				fi
				return $RET
			elif which curl 2>/dev/zero 1>/dev/zero 
			then	curl -o "${DOWNLOAD##*/}" "$DOWNLOAD"
			elif which wget 2>/dev/zero 1>/dev/zero 
			then	wget -O "${DOWNLOAD##*/}" "$DOWNLOAD"
			else	echo "$MSG_NO_DL_APP"
				exit 1
			fi
			[ -f "${DOWNLOAD##*/}" ] && \
				tar -axf "${DOWNLOAD##*/}" && \
				cd tui-master && \
				return 0
			exit 1
		}
		# TUI is found, no download/install required.
		$WHICH tui 2>/dev/null >&2  && return 0
		# TUI is not found, download it or exit with failure
		get_it || { echo "$MSG_NO_INTERNET" ; exit 1 ; }
		# Call proper installation depending on chroot/builddir
		[ -z "${DESTDIR:-${FHS[chroot]}}" ] && \
			$PWD/configure --prefix=${FHS[prefix]} || \
			./configure -c $PWD/configure.yassi --prefix=${FHS[prefix]} --chroot=${FHS[chroot]} 
		cd ..
		echo "(set -x;cd tui-master ; ./make)" >> ./make
		echo "(set -x;cd tui-master ; ./make-install-all)" >> ./make-install
	}
	task_docs() { # INFILE [TYPE=info]
	# Prints the texi2any command to create an info file
	# or another specified TYPE (dvi,html,pdf,ps)
		INFILE="$1"
		DOCTYPE="${2:-info}"
		OUTFILE=${INFILE/\.*/\.$DOCTYPE}
		
		case "${DOCTYPE,,}" in
		info)	echo "texi2any -o \"$OUTFILE\" --no-split \"$INFILE\""
			;;
		*)	echo "texi2any  --$DOCTYPE -o \"$OUTFILE\" --no-split \"$INFILE\""
			;;
		esac
	}
	task_remover() { # ENTRY
	# Catches ENTRY and prints 'rm -f ENTRY' if it is a file/dir
	# Print the line as-is otherwise
		if [ -f "$1" ]
		then 	echo "rm -f \"$1\""
		elif [ -d "$1" ]
		then 	echo "rm -fr \"$1\""
		elif [ "rm" = "${1:0:2}" ]
		then	case "$1" in
			"rm "*|"rmdir "*)
				echo "$1"	;;
			*)	echo "rm -f $1"	;;
			esac
		else	echo "rm -f $1"
		fi
	}
	task_executer() { # ENTRY
	# Catches ENTRY and prints 'sh ./ENTRY'
	# Executes it, or fails if it is a dir.
		if [ -d "$1" ]
		then 	echo "$(eval $MSG_CANNOT_EXE_DIR)" >&2
			exit 1
		elif [ -f "$1" ]
		then	if [ -x "$1" ] 
			then	[ "/" = "${1:0:1}" ] && \
					echo "\"$1\"" || echo "\"$PWD/$1\""
			else	[ "/" = "${1:0:1}" ] && \
					echo "bash \"$1\"" || echo "bash \"$PWD/$1\""
			fi
		else	echo "$1"
		fi
	}
	task_clean() { 
	# Remove the files that where created
	# from 'make' or make 'html'
		[ -f make-clean ] || return 
		texi_convert() { echo "${1%\.texi}.$2";}
		echo "which texi2any 2>/dev/zero 1>/dev/zero || exit 0" >> make-clean
		for T in info html pdf dvi ps;do tData="${DOCS[$T]}" 
			for item in $tData;do echo "rm -f $(texi_convert "$item" "$T")" >> make-clean ;done
		done
	}
	task_distclean() { 
	# Remove all the files that where created by configure
	#
		for task in Makefile make* $REF
		do	task_remover "$task"
		done
	}
	task_dist() { #
	# Packages the project dir without the items of IGNORE[@]
	#
		exclude_list=$(echo [mM]ake* *_dirs.conf)
		for ex in "${IGNORE[@]}";do exclude_list+=" $ex";done
		# Since we prepare the make-<files>, configure is no longer required
		opt_exclude="" #"--exclude-ignore=configure"
		for item in $exclude_list;do opt_exclude+=" --exclude-ignore=$item";done
		
		tmp_p="${PWD:-$(pwd)}"
		tmp_dir="$(dirname $tmp_p)"
		this=${tmp_p/$tmp_dir}
		
		[ -z "$APP_VER" ] && \
			VERSION="" || \
			VERSION="-${APP_VER}"
		# This is just as a failsafe and fallback
		[ ! -z "$TARBALL_DIR" ] && TARBALL="" && \
			( [ -d "$TARBALL_DIR" ] || mkdir -p "$TARBALL_DIR" ) 
		cd "${TARBALL_DIR:-..}"
		#if TARBALL has another path than TARBALL_DIR, that is okay this way
		tarball="${TARBALL:-${APP_NAME}$VERSION.tar.gz}"
		# Actually save this, 
		tar 	-acf "$tarball" \
			--hard-dereference \
			$opt_exclude "${this/\/}"
		RET=$?
		[ 0 -eq $RET ] && \
			echo "$MSG_TARBALL_GOOD ${tarball}!" || \
			echo "$MSG_TARBALL_BAD ${tarball}!"
		cd "$tmp_p"
		unset ${!tmp_*} this
		return $RET
	}
	task_reqs() { # MODE
	# Checks for required commands
	# And prints according function to file: make
		#echo "TODO $FUNCNAME -- medium prio" >&2
		is_there() { which "$1" 2>&1 1>/dev/zero; }
		
		# First do optionals
		opts=""
		for o in "${REQS[opt]}";do is_there "$o" || opts+=" $o";done
		[ -z "$(echo $opts)" || (echo "$MSG_REQS_OPTS";printf '%s\n' $opts)
		
		# Continue with 'requires one of ...'
		C=0 ; 	fatal=0
		while 	[ $C -le ${#REQS_ONE[@]} ]
			[ -n "${REQS_ONE[$C]}"
		do
			found=0
			for req in ${REQS_ONE[$C]};do
				is_there $req && found=$(($found + 1)) 
			done
			[ $found -eq 0 ] && fatal=$(( $fatal + 1)) && \
				echo "${MSG_REQS_ONE} ${REQS_ONE[$C]}"
			((C++))
		done
		[ $fatal -gt 0 ] && exit 1 
		
		# Get the absolute required ones
		[ -z "${REQS[app]}" ] && list="$REQS" || list="${REQS[app]} ${REQS[make]}"
		
		missing=""
		for req in ${REQS[app]};do which $req 2>/dev/zero 1>&2 || missing+=" $req" ;done
		if [ -z "$missing" ]
		then	return 0
		else	printf '%s\n' \
				"$MSG_MISSING_CMDS" #"Sadly, you must figure out the package name yourself."
			printf '::-->> %s\n' \
				${missing}
			exit 1
		fi
	}
	task_download() { #
	# Downloads APP_NAME project according to provided options
	#
		doDL=false outdir=""
		[ -z "$DOWNLOAD_IF_MISSING" ] && return # Nothing todo if its empty
		[ -d "$DOWNLOAD_IF_MISSING" ] || doDL=true
		[ -f "$DOWNLOAD_IF_MISSING" ] && doDL=false || doDL=true
		$doDL || return # its there
		# Prefer git over svn over download
		if [ -n "$GIT" ] && $WHICH git 2>/dev/zero 1>/dev/zero
		then	outdir="$APP_NAME.src"
			git clone "$GIT" "$outdir"
		elif [ -n "$SVN" ] && $WHICH git 2>/dev/zero 1>/dev/zero
		then	outdir="$APP_NAME.src"
			svn checkout "$SVN" "$outdir"
		elif [ -n "$DOWNLOAD" ]
		then	app=""
			if which curl 2>/dev/zero 1>/dev/zero
			then	app=curl ; opt="-o"
			else	app=wget ; opt="-O"	# Hopefully
			fi
			[ -z "$app" ] && printf '%s\n' "$MSG_NO_DL_APP" && exit 1
			$app $opt "${DOWNLOAD##*/}" "$DOWNLOAD"
			tar -axf "${DOWNLOAD##*/}"
			if [ -d "${APP_NAME}" ]
			then	outdir="${APP_NAME}"
			elif [ -d "${APP_NAME}-master" ]
			then	outdir="${APP_NAME}-master"
			elif [ -d "${APP_NAME}-$APP_VER" ]
			then	outdir="${APP_NAME}-$VER"
			else	[ -z "$DOWNLOAD_DIR" && \
					outdir=$($LS -dd $APP_NAME |$AWK '/^d/ {print $9}'|head -n1) \\
					outdir="$DOWNLOAD_DIR"
			fi
		fi
		[ -e "$outdir" ] && printf '%s\n' "$MSG_NO_CODE" && exit 1
		cd "$outdir"
		export doDL
	}
	task_mkdir() { # INDEX
	# Print the code required to create a directory
	# Checking for '/usr-move' and creates symlink if required
		$GREP -q "create_dir=\"${FHS[${1,,}]}\"" make-install && return
		create_dir="${FHS[${1,,}]}"
		cat >> "make-install" <<-EO_SCREEN
		
		create_dir="$create_dir"
		if [ ! -d "\${CHROOT}\${create_dir%/*}" ]
		then 	mkdir -p "\${CHROOT}/usr"
			cd "\${CHROOT}/usr/.."
		 	[ -d "\$CHROOT/usr\${create_dir%/*}" ] && [ -n "\${create_dir%/*}" ] && \\
		 		ln -sf "usr\${create_dir%/*}" "\${create_dir%/*}"
		 	cd "\$OLDPWD"
		fi
		[ -d "\${CHROOT}/\$create_dir" ] || \\
		 	mkdir -p "\${CHROOT}/\$create_dir" || echo >/dev/zero
		EO_SCREEN
	}
	task_uninstall() { # INDEX CONTENT
	# Prints the remove commands
	#
		INDEX="$1" ; shift
		DEST="${CHROOT}${FHS[${INDEX,,}]}"
		
		for tr in ${@}
		do	case "$INDEX" in
			SBINDIR|BINDIR|MANDIR|MAN[1-9]DIR)
				if [ -d "${tr}" ]
				then	for e in "./$tr/"*
					do 	[ -d "$e" ] && \
							echo "rm -fr \${CHROOT}${DEST/$CHROOT}/${e##*/}" || \
							echo "rm -f \${CHROOT}${DEST/$CHROOT}/${e##*/}"
					done
				else	echo "rm -f \${CHROOT}${DEST/$CHROOT}/${tr##*/}"
				fi
				;;
			COMPLDIR)
				# Check if it is a single file or a dir with possible multiple files
				if [ -d "$tr" ]
				then	for this_compl in "$tr/"*
					do 	tmp_compl="${this_compl/\$\{APP_NAME\}/$APP_NAME}"
						echo "rm -f \${CHROOT}${DEST/$CHROOT}/${tmp_compl##*/}"
					done
				else	tr="${tr/\$\{APP_NAME\}/$APP_NAME}"
					echo "rm -f \${CHROOT}${DEST/$CHROOT}/${tr##*/}"
				fi
				;;
			APPDIR|ICONDIR|LOCALEDIR)
				(
					. ./$CFG
					for F in $(cd ${!INDEX}/ ; find -type f )
					do
						[ ! -d "$F" ] && echo "rm -f \${CHROOT}${DEST/$CHROOT}/${F##/*}"
					done
				)
				;;
			*)	[ -d "$tr" ] && \
					echo "rm -fr \${CHROOT}${DEST/$CHROOT}/${tr##*/}" || \
					echo "rm -f \${CHROOT}${DEST/$CHROOT}/${tr##*/}"
				;;
			esac
		done
		return 0
	}
	get_dir() { source "$REF" ; tmp="${1^^}";echo "${!tmp}";unset tmp;}
	get_content() { source "$CFG" ; tmp="${1^^}";echo "${!tmp}";unset tmp;}
	task_install() { # INDEX CONTENT
	# Write the 'install' command for this INDEX and CONTENT
	# Copy all CONTENT of INDEX, preserve same output dir!
		INDEX="$1" ; shift ; ID=${INDEX^^}
		DEST="\${CHROOT}${FHS[${INDEX,,}]}"
		
		# This covers custom created target paths
		tPath="$(get_dir ${INDEX})"
		DEST="${DEST:-$tPath}"
		[ "${1,,}" = root* ] && [ -z "$DEST" ] && DEST="/"
		
		# Parse each 'variable'
		for item in "${@}"
		do 	# Something to do?
			tItem="$(eval echo $item)"
			#tui-title "$INDEX :: $item :: $tItem :: $@ "
			[ -n "$tItem" ] && \
				task_mkdir "$INDEX" >> make-install || \
				continue
			# Get proper string/-formating
			if [ "./" = "${item:0:2}" ] || [ -f "$item" ]
			then	str="$item"
			elif [ -d "$item" ]
			then	str="$item/*"
			else	str="$tItem"
			fi	
			# Install this the simple way
			echo "cp -ar ${str} \"$DEST\"" >> "make-install"
		done
	}
	load_fhs() { #
	# Assign default paths according to: http://www.pathname.com/fhs/
	# The 'appdir', 'icondir' and the 'man[1-9]dir's are 'homebrew' and non-standard, so are root, bootdir, efidir, grubdir and systemddir
		for index in $list_index
		do 	tmp="${FHS[$index]}" ; etc_done=false
			if [ -z "$tmp" ]
			then	case "$index" in
				prefix)		tmp="${APP_DIR}"	;;
				sysconfdir)	tmp_prefix="${FHS[prefix]}"
						case "$tmp_prefix" in
						"/"|"/usr")	tmp="/etc"	;;
						*) 	tmp="${FHS[prefix]}/etc";;
						esac ; etc_done=true	;;
				# --- ---  --- ---  --- ---  --- ---  --- #
				# They dont have ending 'dir' because they are NOT standard!
				root)		tmp="/"	;;
				boot)		tmp="${FHS[rootdir]}/boot"	;;
				efi)		tmp="${FHS[bootdir]}/efi"	;;
				grub)		tmp="${FHS[bootdir]}/grub"	;;
				systemd)	tmp="${FHS[sysconfdir]}/systemd";;
				# --- ---  --- ---  --- ---  --- ---  --- #
				"bindir")	tmp="${FHS[prefix]}/bin"	;;
				"sbindir")	tmp="${FHS[prefix]}/sbin"	;;
				datarootdir)	tmp="${FHS[prefix]}/share"	;;
				appdir)		tmp="${FHS[datarootdir]}/applications"	;;
				icondir)	tmp="${FHS[datarootdir]}/icons"	;;
				datadir)	tmp="${FHS[datarootdir]}/$APP_NAME"	;;
				infodir)	tmp="${FHS[datarootdir]}/info"	;;
				mandir)		tmp="${FHS[datarootdir]}/man" ;;
				man[0-9]dir)	tmp="${FHS[mandir]}/${index:0:4}" ;;
				localedir)	tmp="${FHS[datarootdir]}/locale" ;;
				docdir)		tmp="${FHS[datarootdir]}/doc/$APP_NAME" ;;
				htmldir|dvidir|pdfdir|psdir)	tmp="${FHS[docdir]}" ;;
				compldir)	# Some systems have bash completion within the SYSCONFDIR
						if [ -d "${FHS[datarootdir]}/bash_completion/completions" ]
						then 	tmp="${FHS[datarootdir]}/bash_completion/completions"
						elif [ -d "${FHS[sysconfdir]}/bash_completion.d" ]
						then	tmp="${FHS[sysconfdir]}/bash_completion.d"
						else # Use default as fallback
							tmp="${FHS[datarootdir]}/bash-completion/completions"
						fi ;;
				sharedstatedir)	tmp="${FHS[prefix]}/com"	;;
				localstatedir)	tmp="${FHS[prefix]}/var"	;;
				esac
				if [ "$index" = "prefix" ] && ! $etc_done
				then	# Do special handling
					[ "~" = "${tmp:0:1}" ] && tmp="${tmp/~/$HOME}"
					if [ "${tmp:0:${#HOME}}" = "$HOME" ]
					then	is_at_home=true
						install_prefix=""
						tmp="${tmp/~\/$HOME/$HOME}"
					else	is_at_home=false
					fi
				fi
				FHS["$index"]="$tmp"
			fi
		done
		export FHS is_at_home
	}
	write_file_ref() { #
	# Write the basic reference file
	#
		# Exit with error with $REF is not set
		[ -z "$REF" ] && exit 1 ; >"$REF"
		# Internal defaults
		echo "PREFIX=${FHS[prefix]}">>"$REF"
		for i in $list_variables;do [ -n "${!i}" ] && task_reference "${i^^}" >> "$REF";done
		# Find user homebase
		for that in / /Usr /Os /Sys /System /Var
		do 	for this in Home User Users
			do 	HOMEBASE="$that/$this"
				[ -d "${HOMEBASE}" ] && break 2
				[ -d "${HOMEBASE,,}" ] && HOMEBASE="${HOMEBASE,,}" && break 2
				[ -d "${HOMEBASE^^}" ] && HOMEBASE="${HOMEBASE^^}" && break 2
			done
		done
		[ -d "$HOMEBASE" ] || HOMEBASE=/home	## Using this as fallback
		echo "HOMEBASE=$HOMEBASE" >> "$REF"
		# Custom added dirs
		for D in ${!DIR_*};do echo "$D=\"${!D}\" " >> "$REF";done
	}
	write_file_docs() { #
	# Checks if texi2any is installed and exit if not
	# Converts the texi files to given type
		for type in info html dvi pdf ps;do
			if [ -n "${DOCS[$type]}" ]
			then 	printf '%s\n' \
					'! which texi2any 2>/dev/zero 1>/dev/zero && \' \
					"	echo \"$MSG_NO_TEXI\" && \\" \
					'	exit 1' \
					>> make-doc-$type
				for entry in ${DOCS[$type]};do
					task_docs "$entry" "$type" >> make-doc-$type
				done
			fi
		done
	}
	write_file_headers() { #
	# Creates the ./make* files 
	# and writes the according script headers
		# Basic files
		touch make make-{install,uninstall,distclean}
		$doGNU && touch make-clean make-dist
		[ -n "$(echo ${DOCS[*]})" ] && touch make-install-all
		[ -n "$(echo ${CHECK[*]})" ] && touch make-check
		[ -n "$(echo ${CLEAN[*]})" ] && touch make-clean
		[ -n "$(echo ${DISTCLEAN[*]})" ] && touch make-distclean
		[ -n "$(echo ${INSTALLDIRS[*]})" ] && touch make-installdirs
		[ -n "$(echo ${MOSTLYCLEAN[*]})" ] && touch make-mostlyclean
		[ -n "$(echo ${MAINTAINER_CLEAN[*]})" ] && touch make-maintainer-clean
		# Docs
		for t in info html dvi pdf ps;do
			[ -n "$(echo ${DOCS[$t]})" ] && touch make-doc-$t
		done
		# Write shebang and make the scripts executable		
		for m in ./make*;do
			printf '%s\n' "#!/usr/bin/env bash" \
				"$($VERBOSE && printf '%s\n' 'set -x')" \
				"source $CFG" \
				"source $REF" \
				"CHROOT=\${DESTDIR:-$CHROOT}" \
				> "$m"
			chmod +x "$m"
			
			# Write special content
			case "$m" in
			*install*)	printf '%s\n' "source $REF || { echo \"$MSG_RERUN_CFG\" ; exit 1; }" "$tmp_var" >> "$m"
					if [ "$m" = "make-install" ] && ! echo "$CHROOT/$PREFIX"| $GREP -q -e /home -e /Users -e /users
					then 	printf '%s\n' "[ \${UID:-0} -ne 0 ] && \\"  \
						printf '\t%s\n' "echo \"To ${m/*-} '${APP_TITLE:-APP_NAME}', root access is required.\" && \\" "exit 1" >> "$m"
					fi
					[ "./make-install" = "$m" ] &&   printf '%s\n' "$tmp_var" "[ -z \"\$CHROOT\" ] || mkdir -p \"\$CHROOT\"" >> "$m"
					[ "./make-uninstall" = "$m" ] && printf '%s\n' "[ -n \"\$CHROOT\" ] || CHROOT=\"\""  >>  "$m"
					;;
			esac
		done
		# Write $REF handlers
		if ${doRef:-false}
		then	printf '%s\n' "mkdir -p ${CHROOT}${FHS[sysconfdir]}" \
				"cp $REF ${CHROOT}${FHS[sysconfdir]}/$APP_NAME.conf" >> "make-install"
			printf '%s\n' "rm -f ${CHROOT}${FHS[sysconfdir]}/$APP_NAME.conf" >> "make-uninstall"
		fi
	}
	write_files_content() { #
	# Write the actual content of the scripts
	#
		write_array() { # FILE ARRAY
		# Expand passed ARRAY and write 
		# its content to passed FILE
			C=0;F="$1" ; shift
			while 	item="$(eval echo \${${1}[$C]})"
				[ -n "$item" ]
			do 	case "$F" in
				*clean*|*uninst*)
					task_remover "$item" >> "$F" 	;;
				*)	task_executer "$item" >> "$F" 	;;
				esac
				((C++))
			done
		}
		write_file_install() { #
		# Parse all variables and expand them
		# 
			# Actualy write the make-{un,}install scripts
			for index in $list_variables ${!DIR_*}
			do	# Expand index
				case "$index" in
				DIR_*)	tmp1="${index/DIR_}_DIR"
					tmp="${!tmp1}"	;;
				*)	tmp="${!index}" ;;
				esac
				task_install "$index" "$tmp"
				task_uninstall "$index" "$tmp" >> make-uninstall
			done
			[ -n "$CHROOT" ] && echo "cp -a $REF make-uninstall \"\${CHROOT}\$DATADIR\"" >> "make-install"
		}
		# Actually write the content
		for m in make*;do
			case "$m" in
			"make")		write_array "$m" MAKE 		;;
			"make-install")	[ -n "$MAKE_CREATES" ] && \
						echo "[ ! -f \"$MAKE_CREATES\" ] && echo 'Please run either \"./make\" or \"make\" first!' && exit 1" >> "$m"
					write_array "$m" PRIOR
					write_file_install
					write_array "$m" POST		;;
			"make-check")	write_array "$m" CHECK	 	;;
			"make-uninstall")
					# These two are app specific and can be deleted as is
					[ -n "$(get_dir datadir)" ] && echo "rm -fr \"\${CHROOT}$(get_dir datadir)\"" >> make-uninstall
					[ -n "$(get_dir docdir)" ] && echo "rm -fr \"\${CHROOT}$(get_dir docdir)\"" >> make-uninstall
					# Do manual removals too
					write_array "$m" UNINSTALL 	;;
			"make-clean")
					write_array "$m" CLEAN
					task_clean >> "make-clean"	;;
			"make-dist")	echo "source $CFG" >> make-dist
					LC_ALL=C type task_dist | ${GREP} -v "is a" >> make-dist
					echo task_dist >> make-dist	;;
			"make-distclean")
					write_array "$m" DISTCLEAN 
					>> "make-distclean"
					task_distclean >> "make-distclean";;
			"make-mostlyclean")
					write_array "$m" MOSTLYCLEAN 	;;
			"make-maintainer-clean")
					write_array "$m" MAINTAINER_CLEAN 	;;
			"make-installdirs")
					write_array "$m" INSTALLDIRS 	;;
			esac
		done
	}
	write_file_closer() { #
	# Saves the return code of the last command 
	#
		# Now close the files
		for m in ./make*
		do	$VERBOSE && verbose="set +x" || verbose=""
			printf '%s\n' "RET=\$?" "$( [ -n "$verbose" ] && echo $verbose)" "exit \$RET" >> "$m"
		done
		
	}
	write_file_make() { #
	# Checks for existing scripts and adds them to the makefile
	# Create it either dynamic or add additional make targets
	#
	#	Variables
	#
		# Clear / Init makefile
		($doMakeFile||$doGNU) || return
		local M="./Makefile"
		echo "# This Makefile was generated for ${APP_TITLE:-$APP_NAME} on $(date +'%F') using YASSI ($script_version)" >$M
	#
	#	Function
	#
		regular_handling() { #
		# Write the basic Makefile
		#
			for task in ./make*
			do 	[ "task" = "all" ] && task=install-all
				case "$task" in
				./make)		printf '%s\n' "options:" "	./make"  >> "$M"				;;
				./make-install-all)
					 	if [ -f "$task" ];then
					 		printf '%s\n' "./make" ./make-doc-* "DESTDIR=\${DESTDIR} ./make-install" >> "$task"
						fi 
						[ -f "$task" ] && printf '%s\n' "${task/\.\/make-}:" "	DESTDIR=\${DESTDIR} $task"  >> "$M"
						 ;;
				./make-install)	[ -f "$task" ] && printf '%s\n' "${task/*-}:" "	DESTDIR=\${DESTDIR} ${task}"  >> "$M" ;;
				*-doc-*)	[ -f "$task" ] && printf '%s\n' "${task/*-}:" "	${task}"  >> "$M" 	;;
				*)		[ -f "$task" ] && printf '%s\n' "${task/*-}:" "	${task}"  >> "$M" 		;;
				esac
			done
			echo "PHONY: $(echo make-*|sed s,make\-,,g|sed s,doc\-,install\-,g)" >> "$M"
			
		}
	#
	#	Action & Display
	#
		if $doGNU
		then	# Make the Makefile GNU compliant
			regular_handling
			todo=""
			for m in mostlyclean maintainer-clean installdirs;do [ -f make-$m ] || todo+=" $m";done
			for t in $todo;do echo "PHONY: $t" >> Makefile;echo "$t:" >> Makefile;done
		else	# Regular default handling
			regular_handling
		fi
	}
#
#	Get options
#
	$DEBUG && set -x
	[ -f "$CFG" ] && source "$CFG"		# Overwrite YASSI defaults and load APP-defaults
	GETOPT=$(getopt \
		--options	"hc:t" \
		--longoptions	"help,version,verbose,debug,conf:,manpage,makefile,sample,sample-full,sample-full-clean,chroot:,tarball,bindir:,sbindir:,prefix:,datarootdir:,datadir:,infodir:,mandir,man[1-9]dir:,localedir:,docdir:,compldir:,sharedstatedir:,localstatedir:,localedir:,root:,boot:,efi:,grub:,systemd:" \
		--name 		"${0##*/}" -- "${@}"
	)
	eval set -- "$GETOPT"
	while true
	do 	case "$1" in
		-h|--help)	show_help		;;
		--version)	show_version		;;
		--sample)	show_sample		;;
		--sample-full)	show_sample_full	;;
		--sample-full-clean)	show_sample_full_clean ; exit 0	;;
		--bindir|--sbindir|--datarootdir|--datadir|\
		--infodir|--sysconfdir|--mandir,--man[1-9]dir|\
		--docdir|--htmldir|--dvidir|--pdfdir|--psdir|\
		--compldir|--sharedstatedir|--localstatedir|--localedir|\
		--root|--boot|--efi|--grub)
				FHS["${1/--}"]="$2"
				shift 2		;;
		--prefix)	[ "~" = "${2:0:1}" ] && \
					tmp="${2/\~/$HOME}" || \
					tmp="${2}"
				FHS["${1/--}"]="${tmp}"
				shift 2		;;
		-t|--tarball)	task_dist
				exit $? 		;;
		-c|--conf)	CFG="$2"
				shift 2		;;
		--chroot)	[ -z "$2" ] && continue
				[ "~" = "${2:0:1}" ] && \
					CHROOT="${2/\~/$HOME}" || \
					CHROOT="${2}"
				shift 2		;;
		--makefile)	doMakefile=true
				shift		;;
		--manpage)	if txt2man --help > /dev/zero
				then 	show_manpage | txt2man \
						-t "configure 1" -r "YASSI $script_version" \
						-I "/usr/share/doc/appname" \
						-I "/etc/appname.conf" \
						-I "./make-" \
						-I "./configure" \
						-B "doMakefile" \
						-B "doTUI" \
						-B "doGNU" \
						-B "doRef" \
						> "$MANPAGE"
					man "$MANPAGE" ; rm "$MANPAGE"
				else 	show_manpage
				fi
				exit 0		;;
		--verbose)	VERBOSE=true	;;
		--debug)	VERBOSE=true
				DEBUG=true	;;
		--)		shift ; break	;;
		esac
	done
	[ ! -f "$CFG" ] && echo "$MSG_NO_CONFIG" && exit 1 || source "$CFG"
	[ -z "${APP_NAME/APP*NAME}" ] && echo "$MSG_NO_NAME" && exit 1
	REF="./${APP_NAME}_dirs.conf"
#
#	Prepare Environment
#
	load_fhs
	unset ${list_variables} ${!list_variables}
	source "$CFG"
	write_file_ref
#
#	Prepare installation script
#
	task_download
	write_file_headers
	$doTUI && task_tui
	write_files_content
	write_file_docs
	write_file_make
	write_file_closer
#
#	Quit
#
	RET=$?
	$doDL && cd ..		# Change to parent dir if "task_download" was activated
	$DEBUG && set +x
	export LC_ALL=
	exit $RET
